//Websocketbridge.js
/*!
 * Do not edit!. This file is autogenerated by running `npm run browserify`.
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.channels = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    "use strict";
    ;
    ;
    ;
    var isWebSocket = function (constructor) {
        return constructor && constructor.CLOSING === 2;
    };
    var isGlobalWebSocket = function () {
        return typeof WebSocket !== 'undefined' && isWebSocket(WebSocket);
    };
    var getDefaultOptions = function () { return ({
        constructor: isGlobalWebSocket() ? WebSocket : null,
        maxReconnectionDelay: 10000,
        minReconnectionDelay: 1500,
        reconnectionDelayGrowFactor: 1.3,
        connectionTimeout: 4000,
        maxRetries: Infinity,
        debug: false,
    }); };
    var bypassProperty = function (src, dst, name) {
        Object.defineProperty(dst, name, {
            get: function () { return src[name]; },
            set: function (value) { src[name] = value; },
            enumerable: true,
            configurable: true,
        });
    };
    var initReconnectionDelay = function (config) {
        return (config.minReconnectionDelay + Math.random() * config.minReconnectionDelay);
    };
    var updateReconnectionDelay = function (config, previousDelay) {
        var newDelay = previousDelay * config.reconnectionDelayGrowFactor;
        return (newDelay > config.maxReconnectionDelay)
            ? config.maxReconnectionDelay
            : newDelay;
    };
    var LEVEL_0_EVENTS = ['onopen', 'onclose', 'onmessage', 'onerror'];
    var reassignEventListeners = function (ws, oldWs, listeners) {
        Object.keys(listeners).forEach(function (type) {
            listeners[type].forEach(function (_a) {
                var listener = _a[0], options = _a[1];
                ws.addEventListener(type, listener, options);
            });
        });
        if (oldWs) {
            LEVEL_0_EVENTS.forEach(function (name) {
                ws[name] = oldWs[name];
            });
        }
    };
    var ReconnectingWebsocket = function (url, protocols, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var ws;
        var connectingTimeout;
        var reconnectDelay = 0;
        var retriesCount = 0;
        var shouldRetry = true;
        var savedOnClose = null;
        var listeners = {};
        // require new to construct
        if (!(this instanceof ReconnectingWebsocket)) {
            throw new TypeError("Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator");
        }
        // Set config. Not using `Object.assign` because of IE11
        var config = getDefaultOptions();
        Object.keys(config)
            .filter(function (key) { return options.hasOwnProperty(key); })
            .forEach(function (key) { return config[key] = options[key]; });
        if (!isWebSocket(config.constructor)) {
            throw new TypeError('Invalid WebSocket constructor. Set `options.constructor`');
        }
        var log = config.debug ? function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            return console.log.apply(console, ['RWS:'].concat(params));
        } : function () { };
        /**
         * Not using dispatchEvent, otherwise we must use a DOM Event object
         * Deferred because we want to handle the close event before this
         */
        var emitError = function (code, msg) { return setTimeout(function () {
            var err = new Error(msg);
            err.code = code;
            if (Array.isArray(listeners.error)) {
                listeners.error.forEach(function (_a) {
                    var fn = _a[0];
                    return fn(err);
                });
            }
            if (ws.onerror) {
                ws.onerror(err);
            }
        }, 0); };
        var handleClose = function () {
            log('handleClose', { shouldRetry: shouldRetry });
            retriesCount++;
            log('retries count:', retriesCount);
            if (retriesCount > config.maxRetries) {
                emitError('EHOSTDOWN', 'Too many failed connection attempts');
                return;
            }
            if (!reconnectDelay) {
                reconnectDelay = initReconnectionDelay(config);
            }
            else {
                reconnectDelay = updateReconnectionDelay(config, reconnectDelay);
            }
            log('handleClose - reconnectDelay:', reconnectDelay);
            if (shouldRetry) {
                setTimeout(connect, reconnectDelay);
            }
        };
        var connect = function () {
            if (!shouldRetry) {
                return;
            }
            log('connect');
            var oldWs = ws;
            var wsUrl = (typeof url === 'function') ? url() : url;
            
	    ws = new config.constructor(wsUrl, protocols);
	    
	    if (ws.readyState !== 1) {
	       	return;
	    }

            connectingTimeout = setTimeout(function () {
                log('timeout');
                ws.close();
                emitError('ETIMEDOUT', 'Connection timeout');
            }, config.connectionTimeout);
            log('bypass properties');
            for (var key in ws) {
                // @todo move to constant
                if (['addEventListener', 'removeEventListener', 'close', 'send'].indexOf(key) < 0) {
                    bypassProperty(ws, _this, key);
                }
            }
            ws.addEventListener('open', function () {
                clearTimeout(connectingTimeout);
                log('open');
                reconnectDelay = initReconnectionDelay(config);
                log('reconnectDelay:', reconnectDelay);
                retriesCount = 0;
            });
            ws.addEventListener('close', handleClose);
            reassignEventListeners(ws, oldWs, listeners);
            // because when closing with fastClose=true, it is saved and set to null to avoid double calls
            ws.onclose = ws.onclose || savedOnClose;
            savedOnClose = null;
        };
        log('init');
        connect();
        this.close = function (code, reason, _a) {
            if (code === void 0) { code = 1000; }
            if (reason === void 0) { reason = ''; }
            var _b = _a === void 0 ? {} : _a, _c = _b.keepClosed, keepClosed = _c === void 0 ? false : _c, _d = _b.fastClose, fastClose = _d === void 0 ? true : _d, _e = _b.delay, delay = _e === void 0 ? 0 : _e;
            log('close - params:', { reason: reason, keepClosed: keepClosed, fastClose: fastClose, delay: delay, retriesCount: retriesCount, maxRetries: config.maxRetries });
            shouldRetry = !keepClosed && retriesCount <= config.maxRetries;
            if (delay) {
                reconnectDelay = delay;
            }
            ws.close(code, reason);
            if (fastClose) {
                var fakeCloseEvent_1 = {
                    code: code,
                    reason: reason,
                    wasClean: true,
                };
                // execute close listeners soon with a fake closeEvent
                // and remove them from the WS instance so they
                // don't get fired on the real close.
                handleClose();
                ws.removeEventListener('close', handleClose);
                // run and remove level2
                if (Array.isArray(listeners.close)) {
                    listeners.close.forEach(function (_a) {
                        var listener = _a[0], options = _a[1];
                        listener(fakeCloseEvent_1);
                        ws.removeEventListener('close', listener, options);
                    });
                }
                // run and remove level0
                if (ws.onclose) {
                    savedOnClose = ws.onclose;
                    ws.onclose(fakeCloseEvent_1);
                    ws.onclose = null;
                }
            }
        };
        this.send = function (data) {
            ws.send(data);
        };
        this.addEventListener = function (type, listener, options) {
            if (Array.isArray(listeners[type])) {
                if (!listeners[type].some(function (_a) {
                    var l = _a[0];
                    return l === listener;
                })) {
                    listeners[type].push([listener, options]);
                }
            }
            else {
                listeners[type] = [[listener, options]];
            }
            ws.addEventListener(type, listener, options);
        };
        this.removeEventListener = function (type, listener, options) {
            if (Array.isArray(listeners[type])) {
                listeners[type] = listeners[type].filter(function (_a) {
                    var l = _a[0];
                    return l !== listener;
                });
            }
            ws.removeEventListener(type, listener, options);
        };
    };
    module.exports = ReconnectingWebsocket;
    
    },{}],2:[function(require,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WebSocketBridge = undefined;
    
    var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _reconnectingWebsocket = require('reconnecting-websocket');
    
    var _reconnectingWebsocket2 = _interopRequireDefault(_reconnectingWebsocket);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Bridge between Channels and plain javascript.
     *
     * @example
     * const webSocketBridge = new WebSocketBridge();
     * webSocketBridge.connect();
     * webSocketBridge.listen(function(payload, stream) {
     *   console.log(payload, stream);
     * });
     */
    var WebSocketBridge = function () {
      function WebSocketBridge(options) {
        _classCallCheck(this, WebSocketBridge);
    
        /**
         * The underlaying `ReconnectingWebSocket` instance.
         * 
         * @type {ReconnectingWebSocket}
         */
        this.socket = null;
        this.streams = {};
        this.default_cb = null;
        this.options = _extends({}, options);
      }
    
      /**
       * Connect to the websocket server
       *
       * @param      {String}  [url]     The url of the websocket. Defaults to
       * `window.location.host`
       * @param      {String[]|String}  [protocols] Optional string or array of protocols.
       * @param      {Object} options Object of options for [`reconnecting-websocket`](https://github.com/joewalnes/reconnecting-websocket#options-1).
       * @example
       * const webSocketBridge = new WebSocketBridge();
       * webSocketBridge.connect();
       */
    
    
      _createClass(WebSocketBridge, [{
        key: 'connect',
        value: function connect(url, protocols, options) {
          var _url = void 0;
          // Use wss:// if running on https://
          var scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
          var base_url = scheme + '://' + window.location.host;
          if (url === undefined) {
            _url = base_url;
          } else {
            // Support relative URLs
            if (url[0] == '/') {
              _url = '' + base_url + url;
            } else {
              _url = url;
            }
          }
          this.socket = new _reconnectingWebsocket2.default(_url, protocols, options);
        }
    
        /**
         * Starts listening for messages on the websocket, demultiplexing if necessary.
         *
         * @param      {Function}  [cb]         Callback to be execute when a message
         * arrives. The callback will receive `payload` and `stream` parameters
         *
         * @example
         * const webSocketBridge = new WebSocketBridge();
         * webSocketBridge.connect();
         * webSocketBridge.listen(function(payload, stream) {
        //  *   console.log(payload, stream);
         * });
         */
    
      }, {
        key: 'listen',
        value: function listen(cb) {
          var _this = this;
    
          this.default_cb = cb;
          this.socket.onmessage = function (event) {
            var msg = JSON.parse(event.data);
            var payload = void 0;
            var stream = void 0;
    
            if (msg.stream !== undefined) {
              payload = msg.payload;
              stream = msg.stream;
              var stream_cb = _this.streams[stream];
              stream_cb ? stream_cb(payload, stream) : null;
            } else {
              payload = msg;
              stream = null;
              _this.default_cb ? _this.default_cb(payload, stream) : null;
            }
          };
        }
    
        /**
         * Adds a 'stream handler' callback. Messages coming from the specified stream
         * will call the specified callback.
         *
         * @param      {String}    stream  The stream name
         * @param      {Function}  cb      Callback to be execute when a message
         * arrives. The callback will receive `payload` and `stream` parameters.
           * @example
         * const webSocketBridge = new WebSocketBridge();
         * webSocketBridge.connect();
         * webSocketBridge.listen();
         * webSocketBridge.demultiplex('mystream', function(payload, stream) {
         *   console.log(payload, stream);
         * });
         * webSocketBridge.demultiplex('myotherstream', function(payload, stream) {
         *   console.info(payload, stream);
         * });
         */
    
      }, {
        key: 'demultiplex',
        value: function demultiplex(stream, cb) {
          this.streams[stream] = cb;
        }
    
        /**
         * Sends a message to the reply channel.
         *
         * @param      {Object}  msg     The message
         *
         * @example
         * webSocketBridge.send({prop1: 'value1', prop2: 'value1'});
         */
    
      }, {
        key: 'send',
        value: function send(msg) {
          this.socket.send(JSON.stringify(msg));
        }
    
        /**
         * Returns an object to send messages to a specific stream
         *
         * @param      {String}  stream  The stream name
         * @return     {Object}  convenience object to send messages to `stream`.
         * @example
         * webSocketBridge.stream('mystream').send({prop1: 'value1', prop2: 'value1'})
         */
    
      }, {
        key: 'stream',
        value: function stream(_stream) {
          var _this2 = this;
    
          return {
            send: function send(action) {
              var msg = {
                stream: _stream,
                payload: action
              };
              _this2.socket.send(JSON.stringify(msg));
            }
          };
        }
      }]);
    
      return WebSocketBridge;
    }();
    
    exports.WebSocketBridge = WebSocketBridge;
    
    },{"reconnecting-websocket":1}]},{},[2])(2)
    });

//End websocketbridge.js
//-------------------------------------------------------------------------------




//let audio = new Audio("/static/sound/chime.mp3");

function scrollMessages() {
  /* Set focus on the input box from the form, and rolls to show the
        the most recent message.
    */
  $("textarea[name='message']").focus();
  $("#conversation").scrollTop(99999999999);
}

$(function() {
  //scroll when on textarea
  var div = document.querySelector(".message-scroll");
  var ta = document.querySelector("textarea");

  ta.addEventListener("keydown", autosize);

  function autosize() {
    setTimeout(function() {
      var height = Math.min(20 * 5, ta.scrollHeight);
      div.style.cssText = "height:" + height + "px";
      ta.style.cssText = "height:" + height + "px";
    }, 0);
  }
  var setCookie = function(name, value, days) {
    if (!name && !value) {
      return false;
    } else if (days) {
      var date = new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
      var expires = "; expires=" + date.toGMTString();
    } else var expires = "";
    document.cookie = name + "=" + value + expires + "; path=/";
    return true;
  };
  var getCookie = function(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(";");
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) == " ") c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  };

  var deleteCookie = function(name) {
    if (name) {
      setCookie(name, "", -1);
      return true;
    }
  };
  function loadMessages(chat) {
    var chatURL = chat;
    //Load messages
    $.ajax({
      type: "get",
      url: chatURL,
      success: function(response) {
        var activeUserThumbnail =
          response.active_thumbnail == null
            ? "/static/img/user.png"
            : response.active_thumbnail;

        $(".avatar-container").append(
          `<img src="https://obrisk.oss-cn-hangzhou.aliyuncs.com/${activeUserThumbnail}" alt="Picture Profile"
                        style="width:30px;height:30px;border-radius: 50%;"
                        class=" user-avatar rounded-circle  mb-3 mb-md-0 mr-md-3 profile-header-avatar img-fluid" id="pic">
                    `
        );
        $(".username").append(`  <span>${response.active_username}</span>`);
        response.msgs.map(function(el) {
          if (el.sender_username == response.active_username) {
            if (el.image != null) {
              $("#conversation").append(`<div class="chat-message is-received">

                          <img src="https://obrisk.oss-cn-hangzhou.aliyuncs.com/${activeUserThumbnail}" alt="Picture Profile"
                              style="width:30px;height:30px;border-radius: 50%;"
                              class="rounded-circle  mb-3 mb-md-0 mr-md-3 profile-header-avatar img-fluid" id="pic">

                          <div class="message-block">
                              <span>${moment(el.timestamp).format(
                                "MMM. Do h:mm"
                              )}</span>
                              <a data-fancybox="gallery" style="width: 250px; height: 250px;"
                href="https://obrisk.oss-cn-hangzhou.aliyuncs.com/${
                  el.image
                }"><img
                    style="width: 250px; height: 250px;"
                    src="https://obrisk.oss-cn-hangzhou.aliyuncs.com/${
                      el.img_preview
                    } " /></a>
                          </div>
                      </div > `);
            }
            if (el.classified_title != null) {
              $("#conversation")
                .append(`<div class="chat-message is-received" style="background-color: transparent;"> <img src="https://obrisk.oss-cn-hangzhou.aliyuncs.com/${activeUserThumbnail}" alt="Picture Profile"
                          style="width:30px;height:30px;border-radius: 50%;"
                          class="rounded-circle  mb-3 mb-md-0 mr-md-3 profile-header-avatar img-fluid" id="pic">

                          <div class="message-block">
                            <span>${moment(el.timestamp).format(
                              "MMM. Do h:mm"
                            )}</span>
                            <div class="message-text"><div class="card classified-card mr-2 mb-3 justify-content-center is-flex p-2 " style="max-width: 295px">
            <a href="/classifieds/${
              el.classified_slug
            }" style="color:black; text-decoration:none; background-color:none" class="is-flex">
              <div class="card-img-top img-responsive column" style="max-width: 70px">
                               <img src="https://obrisk.oss-cn-hangzhou.aliyuncs.com/${
                                 el.classified_thumbnail
                               }" alt="${el.classified_title}">

              </div>
              <div class="column">
                <h6 class="card-title"> ${el.classified_title} </h6>
                <p class="card-subtitle O-cl-red"> CNY ${
                  el.classified_price
                } </p>
              </div>
            </a>
          </div></div>
                          </div>
                      </div>`);
            }
            if (el.message != null) {
              $("#conversation")
                .append(`<div class="chat-message is-received" ><img src="https://obrisk.oss-cn-hangzhou.aliyuncs.com/${activeUserThumbnail}" alt="Picture Profile"
                          style="width:30px;height:30px;border-radius: 50%;"
                          class="rounded-circle  mb-3 mb-md-0 mr-md-3 profile-header-avatar img-fluid" id="pic">

                          <div class="message-block">
                            <span>${moment(el.timestamp).format(
                              "MMM. Do h:mm"
                            )}</span>
                            <div class="message-text">${el.message}</div>
                          </div>
                      </div>`);
            }
          } else {
            if (el.image != null) {
              $("#conversation").append(`<div class="chat-message is-sent">

                          <img src="${currentUserThumbnail}" alt="Picture Profile"
                              style="width:30px;height:30px;border-radius: 50%;"
                              class="rounded-circle  mb-3 mb-md-0 mr-md-3 profile-header-avatar img-fluid" id="pic">

                          <div class="message-block">
                              <span>${moment(el.timestamp).format(
                                "MMM. Do h:mm"
                              )}</span>
                              <a data-fancybox="gallery" style="width: 250px; height: 250px;"
                href="https://obrisk.oss-cn-hangzhou.aliyuncs.com/${
                  el.image
                }"><img
                    style="width: 250px; height: 250px;"
                    src="https://obrisk.oss-cn-hangzhou.aliyuncs.com/${
                      el.img_preview
                    } " /></a>
                          </div>
                      </div > `);
            }
            if (el.classified_title != null) {
              $("#conversation")
                .append(`<div class="chat-message is-sent "style="background-color: transparent;"><img src="${currentUserThumbnail}" alt="Picture Profile"
                          style="width:30px;height:30px;border-radius: 50%;"
                          class="rounded-circle  mb-3 mb-md-0 mr-md-3 profile-header-avatar img-fluid" id="pic">

                          <div class="message-block">
                            <span>${moment(el.timestamp).format(
                              "MMM. Do h:mm"
                            )}</span>
                            <div class="message-text"><div class="card classified-card mr-2 mb-3 justify-content-center is-flex p-2 " style="max-width: 295px">
            <a href="/classifieds/${
              el.classified_slug
            }" style="color:black; text-decoration:none; background-color:none" class="is-flex">
              <div class="card-img-top img-responsive column" style="max-width: 70px">
                <img src="https://obrisk.oss-cn-hangzhou.aliyuncs.com/${
                  el.classified_thumbnail
                }" alt="${el.classified_title}">
              </div>
              <div class="column">
                <h6 class="card-title"> ${el.classified_title} </h6>
                <p class="card-subtitle O-cl-red"> CNY ${
                  el.classified_price
                } </p>
              </div>
            </a>
          </div></div></div></div>`);
            }
            if (el.message != null) {
              $("#conversation")
                .append(`<div class="chat-message is-sent" ><img src="${currentUserThumbnail}" alt="Picture Profile"
                          style="width:30px;height:30px;border-radius: 50%;"
                          class="rounded-circle  mb-3 mb-md-0 mr-md-3 profile-header-avatar img-fluid" id="pic">

                          <div class="message-block">
                            <span>${moment(el.timestamp).format(
                              "MMM. Do h:mm"
                            )}</span>
                            <div class="message-text">${el.message}</div>
                          </div>
                      </div>`);
            }
          }
        });

        $(".sendTo").val(response.active_username);
        activeUser = response.active_username;
        $("#conversation").scrollTop(99999999999);
      }
    });
  }

  //This will only run once and then delete the cookies
  if (getCookie("active-chat")) {
    jQuery.noConflict();
    $("#chat-window").modal("show");
    loadMessages(getCookie("active-chat"));
    //Clear the cookies obtained from the classified details
    deleteCookie("active-chat");
  }

  $(".open-chat").click(function() {
    loadMessages($(this).data("url"));
  });

  $(".delete").click(function(e) {
    //Clear previous chat
    $("#conversation").html("");
    $(".avatar-container").html("");
    $(".username").html("");
    $("body").removeClass("modal-open");
    $("body").removeClass("is-frozen");
  });
  function setUserOnlineOffline(username, status) {
    /* This function enables the client to switch the user connection
        status, allowing to show if an user is connected or not.
        */
    var elem = $(".online-stat");
    if (elem) {
      if (status === "online" && username === activeUser) {
        $(".status-light").css("color", "#28a745");
        elem.text("online");
      } else {
        $(".status-light").css("color", "#ffc107");
        elem.text("offline");
      }
    }
  }

  function addNewMessage(message_id) {
    /* This function calls the respective AJAX view, so it will be able to
        load the received message in a proper way.*/
    $.ajax({
      url: "/ws/messages/receive-message/",
      data: {
        message_id: message_id
      },
      cache: false,
      success: function(data) {
        $("#conversation").append(data);
        setTimeout(function() {
          $("#conversation").scrollTop(99999999999);
        }, 200);
      }
    });
    scrollMessages();
  }
  //Remove file upload when user start typing
  $("textarea[name='message']").on(
    "input selectionchange propertychange",
    function() {
      if ($("textarea").val() == "") {
        $("#addBtn").removeClass("is-hidden");
      } else {
        $("#addBtn").addClass("is-hidden");
      }
    }
  );
  $("textarea[name='message']").on("focus", function(e) {
    $("#addBtn").removeClass("is-hidden");
    $("#conversation").scrollTop(99999999999);
  });

  $("#send").submit(function(e) {
    e.preventDefault();
    //make sure the textarea isn't empty before submitting the form
    if ($("textarea").val() != "") {
      var msg = `<div class="chat-message is-sent">

    <img src="${currentUserThumbnail}" alt="Picture Profile" style="width:30px;height:30px;border-radius: 50%;" class="rounded-circle  mb-3 mb-md-0 mr-md-3 profile-header-avatar img-fluid" id="pic">

    <div class="message-block">
        <span>${moment().format("MMM. Do h:mm")}</span>

        <div class="message-text">${$("#sendText").val()}</div>
    </div>
</div>`;
      $("#conversation").append(msg);

      $.ajax({
        url: "/ws/messages/send-message/",
        data: $("#send").serialize(),
        cache: false,
        type: "POST",
        success: function(data) {
          //enable send button after message is sent
          //$('.send-btn').removeAttr("disabled");
          $("#send")[0].reset();
          $("textarea").val("");
          $("textarea[name='message']").focus();
          $("#conversation").scrollTop(99999999999);
        },
        fail: function() {
          $.wnoty({
            type: "error",
            autohide: false,
            message: "failed to send the message"
          });
        }
      });
    }
    return false;
  });

  $("#send-text").click(function(e) {
    e.preventDefault();
    $("#send").trigger("submit");
  });

  //This helps the text in the textarea of the message to be send
  //when press enter and go new line with shift + enter!
  $("#sendText").keypress(function(e) {
    if (
      e.which == 13 &&
      !e.shiftKey &&
      !$(".send-btn").is('[disabled="disabled"]')
    ) {
      $("#send").trigger("submit");
      setTimeout(function(e) {
        $("#conversation").scrollTop(99999999999);
      }, 0);
    }
  });

  // WebSocket connection management block.
  // Correctly decide between ws:// and wss://
  var ws_scheme = window.location.protocol == "https:" ? "wss" : "ws";
  var ws_path =
    ws_scheme +
    "://" +
    window.location.host +
    "/ws/messages/" +
    currentUser +
    "/";
  var webSocket = new channels.WebSocketBridge();
  webSocket.connect(ws_path);

  window.onbeforeunload = function() {
    // Small function to run instruction just before closing the session.
    payload = {
      type: "recieve",
      sender: currentUser,
      set_status: "offline",
      key: "set_status"
    };
    webSocket.send(payload);
  };

  // Helpful debugging
  webSocket.socket.onopen = function() {
    // console.log("Connected to inbox stream");
    // Commenting this block until I find a better way to manage how to
    // report the user status.

    payload = {
      type: "recieve",
      sender: currentUser,
      set_status: "online",
      key: "set_status"
    };

    webSocket.send(payload);
  };

  webSocket.socket.onclose = function() {
    // console.log("Disconnected from inbox stream");
  };

  webSocket.listen(function(event) {
    if (event.key === undefined) event = JSON.parse(event);
    switch (event.key) {
      case "message":
        if (activeUser != "" && activeUser != undefined) {
          if (event.sender === activeUser) {
            addNewMessage(event.message_id);
            // I hope there is a more elegant way to work this out.
            setTimeout(function() {
              $("#unread-count").hide();
            }, 1);
          } else {
            $("#new-message-" + event.sender).show();
          }
        }
        break;

      case "set_status":
        setUserOnlineOffline(event.sender, event.set_status);
        break;
      default:
        break;
    }
    scrollMessages();
  });
});

//localStorage.debug = "ali-oss";
/**
 * fileStats: File statistics
 * filename: The address of the uploaded file
 * * */
var uploader = {
  fileList: [],
  fileStats: {
    totalFilesNum: 0,
    totalFilesSize: 0,
    uploadFinishedFilesNum: 0,
    curFileSize: 0
  }
};

//Upload instance object
var Buffer = OSS.Buffer;
var STS = OSS.STS;
var FileMaxSize = 13000000;
var images;
var img_error; //Records the errors happened during upload.
var client;
var imgClient; //If we'll  be checking the file size.
var ossUpload = "";
var obrisk_oss_url = "https://obrisk.oss-cn-hangzhou.aliyuncs.com/";

let retryCount = 0;
const retryCountMax = 5;

OssUpload.prototype = {
  constructor: OssUpload,
  // Binding event
  bindEvent: function() {
    var _this = this;

    $("#chooseFile, #addBtn").click(function() {
      document.getElementById("image-file").click();
    });

    $('input[type="file"]').change(function(e) {
      if (e.target.files && e.target.files[0]) {
        var reader = new FileReader();
        reader.onload = function() {
          var image = `<div class="chat-message is-sent"><img src="${currentUserThumbnail}" alt="Picture Profile" style="width:30px;height:30px;border-radius: 50%;" class="rounded-circle  mb-3 mb-md-0 mr-md-3 profile-header-avatar img-fluid is-hidden-mobile" id="pic"><div class="message-block"><span>${moment().format(
            "MMM. Do h:mm"
          )}</span><a data-fancybox="gallery" href="${
            reader.result
          }"><img style="width: 250px; height: 250px;" src="${
            reader.result
          }"></a></div></div>`;
          $("#conversation").append(image);
          $("#conversation").scrollTop(99999999999);
        };
        reader.readAsDataURL(e.target.files[0]);
      }
      var files = e.target.files;
      var curIndex = uploader.fileList.length; //The length of the file already in the plugin, append
      var NumberOfSelectedFiles = files.length;
      var file = null;
      $("#uploader .placeholder").hide();
      $("#statusBar").css("display", "flex");

      if (files.length == 0) {
        alert("No image selected , Please select one or more images");
      } else {
        for (var i = 0; i < NumberOfSelectedFiles; i++) {
          file = files[i];
          //don't upload files with size greater than 13MB
          if (file.size <= FileMaxSize) {
            uploader.fileList[curIndex + i] = file;
            file.id = uploader.fileList[curIndex + i].id =
              "image" + (curIndex + i + 1); //Add id to each file
            uploader.fileStats.totalFilesSize += file.size; //Statistical file size
          } else {
            alert(
              file.name +
                " is larger than 13MB, please select images small than 13MB "
            );
          }
        }
        $(".addBtn").hide();
      }
      uploader.fileStats.totalFilesNum = uploader.fileList.length;
      if (uploader.fileStats.totalFilesNum == 0) {
        event.preventDefault();
        alert("Please select images to upload!");
        $(".start-uploader").css("display", "block");
      } else {
        var length = uploader.fileStats.totalFilesNum;

        for (var i = 0; i < length; i++) {
          var filename = genKey();
          file = uploader.fileList[i];
          _this.uploadFile(file, filename);
        }
        uploader = {
          fileList: [],
          fileStats: {
            totalFilesNum: 0,
            totalFilesSize: 0,
            uploadFinishedFilesNum: 0,
            curFileSize: 0
          }
        };
      }
    });

    $(".retry-upload").on("click", function(image) {
      e.preventDefault();
      var length = uploader.fileStats.totalFilesNum;

      for (var i = 0; i < length; i++) {
        var filename = genKey();
        file = uploader.fileList[i];
        _this.uploadFile(file, filename);
      }
      uploader = {
        fileList: [],
        fileStats: {
          totalFilesNum: 0,
          totalFilesSize: 0,
          uploadFinishedFilesNum: 0,
          curFileSize: 0
        }
      };
    });
  },

  /***
   *  upload files
   * @param file files to be uploaded
   * @param filename to which location to upload the file. According to the official statement is the key
   * oss is object storage, there is no path path concept, but personally think this can be better understood as a path
   */
  uploadFile: function(file, filename) {
    $totalProgressbar.css("width", "30%").html("Uploading...");
    applyTokenDo()
      .then(result => {
        if (!result.direct) {
          client = new OSS({
            region: result.region,
            accessKeyId: result.accessKeyId,
            accessKeySecret: result.accessKeySecret,
            stsToken: result.SecurityToken,
            bucket: result.bucket
          });
        } else {
          client = new OSS({
            region: result.region,
            accessKeyId: result.accessId,
            accessKeySecret: result.stsTokenKey,
            bucket: result.bucket
          });
        }

        //make sure we get the sts token
        if (client !== undefined) {
          const upload = async () => {
            try {
              const results = await client
                .multipartUpload(filename, file, {
                  progress: progress,
                  partSize: 200 * 1024, //Minimum is 100*1024
                  timeout: 120000 // 2 minutes timeout
                })
                .then(function(res) {
                  //Try to get the dominat color from the uploaded image, if it fails it means the image
                  //was corrupted during upload

                  //
                  $.ajax({
                    url:
                      obrisk_oss_url +
                      res.name +
                      "?x-oss-process=image/average-hue",
                    success: function() {
                      $("#" + file.id)
                        .children(".success-span")
                        .addClass("success");
                      $("#" + file.id)
                        .children(".file-panel")
                        .hide();
                      uploader.fileStats.uploadFinishedFilesNum++; //Successfully uploaded + 1
                      uploader.fileStats.curFileSize += file.size; //Currently uploaded file size
                      progressBarNum =
                        (
                          uploader.fileStats.curFileSize /
                          uploader.fileStats.totalFilesSize
                        ).toFixed(2) * 100;
                      progressBar =
                        (
                          uploader.fileStats.curFileSize /
                          uploader.fileStats.totalFilesSize
                        ).toFixed(2) *
                          100 +
                        "%";

                      if (progressBarNum == 100) {
                        $totalProgressbar
                          .css("width", progressBar)
                          .html("Upload complete");
                      } else {
                        $totalProgressbar
                          .css("width", progressBar)
                          .html(progressBar);
                      }

                      $("#image").val(res.name);
                      //Send image to chat

                      $.ajax({
                        url: "/ws/messages/send-message/",
                        data: $("#upload").serialize(),
                        cache: false,
                        type: "POST",
                        success: function(data) {
                          $("#image").val("");
                        },
                        fail: function(err) {
                          $("body").trigg("showRetry");
                          console.log(err);
                        }
                      });
                    },
                    error: function(e) {
                      // if a file is corrupted during upload retry 5 times to upload it then skip it and return an error message
                      if (retryCount < retryCountMax) {
                        retryCount++;
                        console.error(`retryCount : ${retryCount}`);
                        upload();
                      } else {
                        //We have retried to the max and there is nothing we can do
                        //Allow the users to submit the form atleast with default image.

                        $("#" + file.id)
                          .children(".success-span")
                          .addClass("fail");
                        $("#" + file.id)
                          .children(".file-panel")
                          .hide();
                        uploader.fileStats.uploadFinishedFilesNum++; //Successfully uploaded + 1
                        uploader.fileStats.curFileSize += file.size; //Currently uploaded file size
                        progressBarNum =
                          (
                            uploader.fileStats.curFileSize /
                            uploader.fileStats.totalFilesSize
                          ).toFixed(2) * 100;
                        progressBar =
                          (
                            uploader.fileStats.curFileSize /
                            uploader.fileStats.totalFilesSize
                          ).toFixed(2) *
                            100 +
                          "%";

                        if (progressBarNum == 100) {
                          $totalProgressbar
                            .css("width", progressBar)
                            .html("Upload complete");
                        } else {
                          $totalProgressbar
                            .css("width", progressBar)
                            .html(progressBar);
                        }
                        img_error =
                          res.name +
                          ", Message: " +
                          "Corrupted image" +
                          ", RequestID: " +
                          res.name;
                        if (!images) {
                          images = "undef,classifieds/error-img.jpg";
                          alert(
                            "Oops! an error occured when uploading your image(s). Please try again later"
                          );
                        }
                      }
                    }
                  }); //End of ajax function
                })
                .catch(err => {
                  console.error(err);
                  console.log(`err.name : ${err.name}`);
                  console.log(`err.message : ${err.message}`);
                  console.log(`err.request : ${err.requestId}`);

                  $totalProgressbar.css("width", "40%").html("Retrying...");

                  if (
                    err.name.toLowerCase().indexOf("connectiontimeout") !== -1
                  ) {
                    if (retryCount < retryCountMax) {
                      retryCount++;
                      console.error(`retryCount : ${retryCount}`);
                      upload();
                    } else {
                      //We have retried to the max and there is nothing we can do
                      //Allow the users to submit the form atleast with default image.
                      $totalProgressbar
                        .css("width", "94%")
                        .html("Completed with minor errors!");
                      $("ul.filelist li")
                        .children(".success-span")
                        .addClass("fail");
                      img_error =
                        err.name +
                        ", Message: " +
                        err.message +
                        ", RequestID: " +
                        err.requestId;

                      if (!images) {
                        images = "undef,classifieds/error-img.jpg";
                        alert(
                          "Oops! an error occured when uploading your image(s). Please try again later"
                        );
                      }
                    }
                  } else {
                    //Not timeout out error and there is nothing we can do
                    //Allow the users to submit the form atleast with default image.
                    $totalProgressbar
                      .css("width", "94%")
                      .html("Completed with minor errors!");

                    img_error =
                      err.name +
                      ", Message: " +
                      err.message +
                      ", RequestID: " +
                      err.requestId;

                    if (!images) {
                      images = "undef,classifieds/error-img.jpg";
                      alert(
                        "Oops! an error occured when uploading your image(s). Please try again later"
                      );
                    }
                  }
                });
              return results;
            } catch (e) {
              alert(
                "Oops! an error occured when uploading your image(s), \
                    Please try again later or contact us via support@obrisk.com. " +
                  e
              );
              $(".start-uploader").css("display", "block");
              console.log(e);
            }
          };
          return upload();
        } else {
          alert(
            "Oops!, it looks like there is a network problem, \
            Please try again later or contact us at support@obrisk.com"
          );
          $(".start-uploader").css("display", "block");
        }
      })
      .catch(e => {
        alert(
          "Oops! an error occured before upload started, Please try again later or contact us via support@obrisk.com" +
            e
        );
        console.log(e);
      });
  }
};

/**
 * Create progress bar
 */
var progressBar = 0;
var progress = "";
var $wrap = $("#uploader"),
  // Picture container
  $queue = $('<ul class="filelist"></ul>').appendTo($wrap.find(".queueList")),
  $totalProgressbar = $("#totalProgressBar");

var progress = function(p) {
  //p percentage 0~1
  return function(done) {
    $totalProgressbar.css("width", progressBar);
    done();
  };
};

/**
 * get sts token
 *
 * TODO neeeds improvment to make ajax call ony when token has expired
 */
var applyTokenDo = function() {
  var url = oss_url; //Request background to obtain authorization address url
  return new Promise((resolve, reject) => {
    $.ajax({
      url: url,
      success: function(result) {
        resolve(result);
      },
      error: function(e) {
        reject(e);
      }
    });
  });
};

//File upload initializer
function OssUpload() {
  var _this = this;
  _this.init = function() {
    _this.initPage();
    _this.bindEvent();
  };
  _this.initPage = function() {};
}

/**
 * generate file name using uuid
 *
 * @return  {string}
 */

function genKey() {
  return (
    "messages/" +
    currentUser +
    "/" +
    activeUser +
    "/" +
    "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = (Math.random() * 16) | 0,
        v = c == "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    })
  );
}

/**
 * create a slug
 *
 * @param   {string}  string  string to be slugified
 *
 * @return  {slug}          slugified string
 */
function slugify(string) {
  const a = "àáäâãåăæçèéëêǵḧìíïîḿńǹñòóöôœøṕŕßśșțùúüûǘẃẍÿź·/_,:;";
  const b = "aaaaaaaaceeeeghiiiimnnnooooooprssstuuuuuwxyz------";
  const p = new RegExp(a.split("").join("|"), "g");
  return string
    .toString()
    .toLowerCase()
    .replace(/\s+/g, "-") // Replace spaces with -
    .replace(p, c => b.charAt(a.indexOf(c))) // Replace special characters
    .replace(/&/g, "-and-") // Replace & with ‘and’
    .replace(/[^\w\-]+/g, "") // Remove all non-word characters
    .replace(/\-\-+/g, "-") // Replace multiple - with single -
    .replace(/^-+/, "") // Trim - from start of text
    .replace(/-+$/, ""); // Trim - from end of text
}

$(function() {
  //create and initialize upload object
  ossUpload = new OssUpload();
  ossUpload.init();
});
