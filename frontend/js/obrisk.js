/* Project specific Javascript goes here. */

/*
Formatting hack to get around crispy-forms unfortunate hardcoding
in helpers.FormHelper:

    if template_pack == 'bootstrap4':
        grid_colum_matcher = re.compile('\w*col-(xs|sm|md|lg|xl)-\d+\w*')
        using_grid_layout = (grid_colum_matcher.match(self.label_class) or
                             grid_colum_matcher.match(self.field_class))
        if using_grid_layout:
            items['using_grid_layout'] = True

Issues with the above approach:

1. Fragile: Assumes Bootstrap 4's API doesn't change (it does)
2. Unforgiving: Doesn't allow for any variation in template design
3. Really Unforgiving: No way to override this behavior
4. Undocumented: No mention in the documentation, or it's too hard for me to find
*/

//Websocketbridge.js
/*!
 * Do not edit!. This file is autogenerated by running `npm run browserify`.
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.channels = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    "use strict";
    ;
    ;
    ;
    var isWebSocket = function (constructor) {
        return constructor && constructor.CLOSING === 2;
    };
    var isGlobalWebSocket = function () {
        return typeof WebSocket !== 'undefined' && isWebSocket(WebSocket);
    };
    var getDefaultOptions = function () { return ({
        constructor: isGlobalWebSocket() ? WebSocket : null,
        maxReconnectionDelay: 10000,
        minReconnectionDelay: 1500,
        reconnectionDelayGrowFactor: 1.3,
        connectionTimeout: 4000,
        maxRetries: Infinity,
        debug: false,
    }); };
    var bypassProperty = function (src, dst, name) {
        Object.defineProperty(dst, name, {
            get: function () { return src[name]; },
            set: function (value) { src[name] = value; },
            enumerable: true,
            configurable: true,
        });
    };
    var initReconnectionDelay = function (config) {
        return (config.minReconnectionDelay + Math.random() * config.minReconnectionDelay);
    };
    var updateReconnectionDelay = function (config, previousDelay) {
        var newDelay = previousDelay * config.reconnectionDelayGrowFactor;
        return (newDelay > config.maxReconnectionDelay)
            ? config.maxReconnectionDelay
            : newDelay;
    };
    var LEVEL_0_EVENTS = ['onopen', 'onclose', 'onmessage', 'onerror'];
    var reassignEventListeners = function (ws, oldWs, listeners) {
        Object.keys(listeners).forEach(function (type) {
            listeners[type].forEach(function (_a) {
                var listener = _a[0], options = _a[1];
                ws.addEventListener(type, listener, options);
            });
        });
        if (oldWs) {
            LEVEL_0_EVENTS.forEach(function (name) {
                ws[name] = oldWs[name];
            });
        }
    };
    var ReconnectingWebsocket = function (url, protocols, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var ws;
        var connectingTimeout;
        var reconnectDelay = 0;
        var retriesCount = 0;
        var shouldRetry = true;
        var savedOnClose = null;
        var listeners = {};
        // require new to construct
        if (!(this instanceof ReconnectingWebsocket)) {
            throw new TypeError("Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator");
        }
        // Set config. Not using `Object.assign` because of IE11
        var config = getDefaultOptions();
        Object.keys(config)
            .filter(function (key) { return options.hasOwnProperty(key); })
            .forEach(function (key) { return config[key] = options[key]; });
        if (!isWebSocket(config.constructor)) {
            throw new TypeError('Invalid WebSocket constructor. Set `options.constructor`');
        }
        var log = config.debug ? function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            return console.log.apply(console, ['RWS:'].concat(params));
        } : function () { };
        /**
         * Not using dispatchEvent, otherwise we must use a DOM Event object
         * Deferred because we want to handle the close event before this
         */
        var emitError = function (code, msg) { return setTimeout(function () {
            var err = new Error(msg);
            err.code = code;
            if (Array.isArray(listeners.error)) {
                listeners.error.forEach(function (_a) {
                    var fn = _a[0];
                    return fn(err);
                });
            }
            if (ws.onerror) {
                ws.onerror(err);
            }
        }, 0); };
        var handleClose = function () {
            log('handleClose', { shouldRetry: shouldRetry });
            retriesCount++;
            log('retries count:', retriesCount);
            if (retriesCount > config.maxRetries) {
                emitError('EHOSTDOWN', 'Too many failed connection attempts');
                return;
            }
            if (!reconnectDelay) {
                reconnectDelay = initReconnectionDelay(config);
            }
            else {
                reconnectDelay = updateReconnectionDelay(config, reconnectDelay);
            }
            log('handleClose - reconnectDelay:', reconnectDelay);
            if (shouldRetry) {
                setTimeout(connect, reconnectDelay);
            }
        };
        var connect = function () {
            if (!shouldRetry) {
                return;
            }
            log('connect');
            var oldWs = ws;
            var wsUrl = (typeof url === 'function') ? url() : url;
            
	    ws = new config.constructor(wsUrl, protocols);
	    
	    if (ws.readyState !== 1) {
	       	return;
	    }

            connectingTimeout = setTimeout(function () {
                log('timeout');
                ws.close();
                emitError('ETIMEDOUT', 'Connection timeout');
            }, config.connectionTimeout);
            log('bypass properties');
            for (var key in ws) {
                // @todo move to constant
                if (['addEventListener', 'removeEventListener', 'close', 'send'].indexOf(key) < 0) {
                    bypassProperty(ws, _this, key);
                }
            }
            ws.addEventListener('open', function () {
                clearTimeout(connectingTimeout);
                log('open');
                reconnectDelay = initReconnectionDelay(config);
                log('reconnectDelay:', reconnectDelay);
                retriesCount = 0;
            });
            ws.addEventListener('close', handleClose);
            reassignEventListeners(ws, oldWs, listeners);
            // because when closing with fastClose=true, it is saved and set to null to avoid double calls
            ws.onclose = ws.onclose || savedOnClose;
            savedOnClose = null;
        };
        log('init');
        connect();
        this.close = function (code, reason, _a) {
            if (code === void 0) { code = 1000; }
            if (reason === void 0) { reason = ''; }
            var _b = _a === void 0 ? {} : _a, _c = _b.keepClosed, keepClosed = _c === void 0 ? false : _c, _d = _b.fastClose, fastClose = _d === void 0 ? true : _d, _e = _b.delay, delay = _e === void 0 ? 0 : _e;
            log('close - params:', { reason: reason, keepClosed: keepClosed, fastClose: fastClose, delay: delay, retriesCount: retriesCount, maxRetries: config.maxRetries });
            shouldRetry = !keepClosed && retriesCount <= config.maxRetries;
            if (delay) {
                reconnectDelay = delay;
            }
            ws.close(code, reason);
            if (fastClose) {
                var fakeCloseEvent_1 = {
                    code: code,
                    reason: reason,
                    wasClean: true,
                };
                // execute close listeners soon with a fake closeEvent
                // and remove them from the WS instance so they
                // don't get fired on the real close.
                handleClose();
                ws.removeEventListener('close', handleClose);
                // run and remove level2
                if (Array.isArray(listeners.close)) {
                    listeners.close.forEach(function (_a) {
                        var listener = _a[0], options = _a[1];
                        listener(fakeCloseEvent_1);
                        ws.removeEventListener('close', listener, options);
                    });
                }
                // run and remove level0
                if (ws.onclose) {
                    savedOnClose = ws.onclose;
                    ws.onclose(fakeCloseEvent_1);
                    ws.onclose = null;
                }
            }
        };
        this.send = function (data) {
            ws.send(data);
        };
        this.addEventListener = function (type, listener, options) {
            if (Array.isArray(listeners[type])) {
                if (!listeners[type].some(function (_a) {
                    var l = _a[0];
                    return l === listener;
                })) {
                    listeners[type].push([listener, options]);
                }
            }
            else {
                listeners[type] = [[listener, options]];
            }
            ws.addEventListener(type, listener, options);
        };
        this.removeEventListener = function (type, listener, options) {
            if (Array.isArray(listeners[type])) {
                listeners[type] = listeners[type].filter(function (_a) {
                    var l = _a[0];
                    return l !== listener;
                });
            }
            ws.removeEventListener(type, listener, options);
        };
    };
    module.exports = ReconnectingWebsocket;
    
    },{}],2:[function(require,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.WebSocketBridge = undefined;
    
    var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _reconnectingWebsocket = require('reconnecting-websocket');
    
    var _reconnectingWebsocket2 = _interopRequireDefault(_reconnectingWebsocket);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Bridge between Channels and plain javascript.
     *
     * @example
     * const webSocketBridge = new WebSocketBridge();
     * webSocketBridge.connect();
     * webSocketBridge.listen(function(payload, stream) {
     *   console.log(payload, stream);
     * });
     */
    var WebSocketBridge = function () {
      function WebSocketBridge(options) {
        _classCallCheck(this, WebSocketBridge);
    
        /**
         * The underlaying `ReconnectingWebSocket` instance.
         * 
         * @type {ReconnectingWebSocket}
         */
        this.socket = null;
        this.streams = {};
        this.default_cb = null;
        this.options = _extends({}, options);
      }
    
      /**
       * Connect to the websocket server
       *
       * @param      {String}  [url]     The url of the websocket. Defaults to
       * `window.location.host`
       * @param      {String[]|String}  [protocols] Optional string or array of protocols.
       * @param      {Object} options Object of options for [`reconnecting-websocket`](https://github.com/joewalnes/reconnecting-websocket#options-1).
       * @example
       * const webSocketBridge = new WebSocketBridge();
       * webSocketBridge.connect();
       */
    
    
      _createClass(WebSocketBridge, [{
        key: 'connect',
        value: function connect(url, protocols, options) {
          var _url = void 0;
          // Use wss:// if running on https://
          var scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
          var base_url = scheme + '://' + window.location.host;
          if (url === undefined) {
            _url = base_url;
          } else {
            // Support relative URLs
            if (url[0] == '/') {
              _url = '' + base_url + url;
            } else {
              _url = url;
            }
          }
          this.socket = new _reconnectingWebsocket2.default(_url, protocols, options);
        }
    
        /**
         * Starts listening for messages on the websocket, demultiplexing if necessary.
         *
         * @param      {Function}  [cb]         Callback to be execute when a message
         * arrives. The callback will receive `payload` and `stream` parameters
         *
         * @example
         * const webSocketBridge = new WebSocketBridge();
         * webSocketBridge.connect();
         * webSocketBridge.listen(function(payload, stream) {
        //  *   console.log(payload, stream);
         * });
         */
    
      }, {
        key: 'listen',
        value: function listen(cb) {
          var _this = this;
    
          this.default_cb = cb;
          this.socket.onmessage = function (event) {
            var msg = JSON.parse(event.data);
            var payload = void 0;
            var stream = void 0;
    
            if (msg.stream !== undefined) {
              payload = msg.payload;
              stream = msg.stream;
              var stream_cb = _this.streams[stream];
              stream_cb ? stream_cb(payload, stream) : null;
            } else {
              payload = msg;
              stream = null;
              _this.default_cb ? _this.default_cb(payload, stream) : null;
            }
          };
        }
    
        /**
         * Adds a 'stream handler' callback. Messages coming from the specified stream
         * will call the specified callback.
         *
         * @param      {String}    stream  The stream name
         * @param      {Function}  cb      Callback to be execute when a message
         * arrives. The callback will receive `payload` and `stream` parameters.
           * @example
         * const webSocketBridge = new WebSocketBridge();
         * webSocketBridge.connect();
         * webSocketBridge.listen();
         * webSocketBridge.demultiplex('mystream', function(payload, stream) {
         *   console.log(payload, stream);
         * });
         * webSocketBridge.demultiplex('myotherstream', function(payload, stream) {
         *   console.info(payload, stream);
         * });
         */
    
      }, {
        key: 'demultiplex',
        value: function demultiplex(stream, cb) {
          this.streams[stream] = cb;
        }
    
        /**
         * Sends a message to the reply channel.
         *
         * @param      {Object}  msg     The message
         *
         * @example
         * webSocketBridge.send({prop1: 'value1', prop2: 'value1'});
         */
    
      }, {
        key: 'send',
        value: function send(msg) {
          this.socket.send(JSON.stringify(msg));
        }
    
        /**
         * Returns an object to send messages to a specific stream
         *
         * @param      {String}  stream  The stream name
         * @return     {Object}  convenience object to send messages to `stream`.
         * @example
         * webSocketBridge.stream('mystream').send({prop1: 'value1', prop2: 'value1'})
         */
    
      }, {
        key: 'stream',
        value: function stream(_stream) {
          var _this2 = this;
    
          return {
            send: function send(action) {
              var msg = {
                stream: _stream,
                payload: action
              };
              _this2.socket.send(JSON.stringify(msg));
            }
          };
        }
      }]);
    
      return WebSocketBridge;
    }();
    
    exports.WebSocketBridge = WebSocketBridge;
    
    },{"reconnecting-websocket":1}]},{},[2])(2)
    });

//End websocketbridge.js
//-------------------------------------------------------------------------------



//Push notifications code
//-------------------------------------------------------------------------------

const swSubReg = async () => {
    if ('serviceWorker' in navigator) {
        const reg = await navigator.serviceWorker.register('/serviceworker.js');
        initialiseState(reg)

    } else {
        showNotAllowed("You can't send push notifications ☹️😢")
    }
};

const initialiseState = (reg) => {
    if (!reg.showNotification) {
        showNotAllowed('Showing notifications isn\'t supported ☹️😢');
        return
    }
    if (Notification.permission === 'denied') {
        showNotAllowed('You prevented us from showing notifications ☹️🤔');
        return
    }
    if (!'PushManager' in window) {
        showNotAllowed("Push notifications aren't allowed in your browser 🤔");
        return
    }
    subscribe(reg);
}

const showNotAllowed = (message) => {
    console.log("push notifications show not allowed");
};


function urlB64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');

    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    const outputData = outputArray.map((output, index) => rawData.charCodeAt(index));

    return outputData;
}

const subscribe = async (reg) => {
    const subscription = await reg.pushManager.getSubscription();
    if (subscription) {
        sendSubData(subscription);
        return;
    }

    const vapidMeta = document.querySelector('meta[name="vapid-key"]');
    const key = vapidMeta.content;
    const options = {
        userVisibleOnly: true,
	applicationServerKey: urlB64ToUint8Array(key)
    };

    const sub = await reg.pushManager.subscribe(options);
    sendSubData(sub)
};


const sendSubData = async (subscription) => {
    const browser = navigator.userAgent.match(/(firefox|msie|chrome|safari|trident)/ig)[0].toLowerCase();
    const data = {
        status_type: 'subscribe',
        subscription: subscription.toJSON(),
        browser: browser,
    };

    const res = await fetch('/webpush/save_information', {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
            'content-type': 'application/json'
        },
        credentials: "include"
    });

    handleResponse(res);
};

const handleResponse = (res) => {
    console.log(res.status);
};

swSubReg();

//End push notif code
//-------------------------------------------------------------------------------
//

/* Notifications JS basic client */
document.addEventListener('DOMContentLoaded', function() {
  let emptyMessage = "You have no unread notification";

  function checkNotifications() {
        fetch("/ws/notifications/latest-notifications/")
        .then(function(response) {
            // with the response, parse to text, then pass it along
            response.text().then(function(data) {
            document.querySelector(".recent-notifications").innerHTML= data;
            //if (!data.includes(emptyMessage)) { //seems is-notify is not in the DOM
               //document.querySelector(".is-notify").classList.add("notification--num");
            //}
        });
    });
  }

  function update_social_activity(id_value) {
    let storiesToUpdate = document.querySelector("[stories-id=" + id_value + "]");
    payload = {
      id_value: id_value,
      'csrfmiddlewaretoken': document.querySelector(
               '#csrf-helper input[name="csrfmiddlewaretoken"]'
           ).getAttribute('value')
    };

    fetch('/stories/update-interactions/', {
        method: 'POST',
        body: payload,
        credentials: 'same-origin'
    }).then(function(response) {
        // with the response, parse to text, then pass it along
        response.text().then(function(data) {
            document.querySelector(".like-count", storiesToUpdate).textContent(data.likes);
            document.querySelector(".comment-count", storiesToUpdate).textContent(data.comments);
        });
    });
  }

  /*const notif = document.querySelector(".notifications");

  notif.addEventListener('click', function(e) {
    if (notif.contains(".recent-notifications #close")) { //if (notif.is(.recent-not...)
          document.querySelector(".recent-notifications").classList.remove("is-active");
    } else {
          document.querySelector(".recent-notifications").innerHTML = "";
          checkNotifications();
    }
    return false;
  });
  */

  //checkNotifications();

  // Code block to manage WebSocket connections for notifications
  // Try to correctly decide between ws:// and wss://
  const ws_scheme = window.location.protocol == "https:" ? "wss" : "ws";
  const socket_notif = new Audio("/static/sound/knock_brush.ogg");
  const ws_path = ws_scheme + "://" + window.location.host + "/ws/notifications/";
  const webSocket = new channels.WebSocketBridge();

  webSocket.connect(ws_path);

  webSocket.listen(function(event) {
    if (event.key === undefined) event = JSON.parse(event);
    switch (event.key) {
      case "new_message":
        if (event.recipient == currentUser) {
          socket_notif.play();
          document.querySelector(".msg-notification i").style.display = 'block !important';
        }
        break;
      default:
        break;
    }
  });

  // When debugging websockets uncomment these lines.
  //Now it is still JQuery it has to be converted to vanilla JS
  // webSocket.socket.onopen = function () {
  //     //console.log("Connected to " + ws_path);
  // };

  // webSocket.socket.onclose = function () {
  //     //console.log("Disconnected from " + ws_path);
  // };

  // Listen the WebSocket bridge created throug django-channels library.
  // webSocket.listen(function(event) {
  //     switch (event.key) {
  //         case "notification":
  //             $("#notifications").addClass("btn-dark");
  //             break;

  //         case "social_update":
  //             $("#notifications").addClass("btn-dark");
  //             update_social_activity(event.id_value);
  //             break;

  //         case "additional_stories":
  //             if (event.actor_name !== currentUser) {
  //                 $(".stream-update").show();
  //             }
  //             break;

  //         default:
  //             // console.log('error: ', event);
  //             break;
  //     };
  // });
});
